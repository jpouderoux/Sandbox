<?xml version="1.0\"?>
<typesystem package="Example">

  <primitive-type name="bool"/>
  <primitive-type name="double"/>
  <primitive-type name="real"/>
  <primitive-type name="int"/>
  <primitive-type name="short"/>
  <primitive-type name="unsigned short"/>
  <primitive-type name="ushort"/>
  <primitive-type name="unsigned int" />
  <primitive-type name="signed int" />
  <primitive-type name="char"/>
  <primitive-type name="unsigned char"/>
  <primitive-type name="long"/>
  <primitive-type name="unsigned long"/>
  <primitive-type name="long long"/>
  <primitive-type name="unsigned long long"/>

  <primitive-type name="std::size_t"/>
  <primitive-type name="std::string"/>

  <container-type name="std::pair" type="pair">
        <include file-name="utility" location="global"/>
        <conversion-rule>
            <native-to-target>
            PyObject* %out = PyTuple_New(2);
            PyTuple_SET_ITEM(%out, 0, %CONVERTTOPYTHON[%INTYPE_0](%in.first));
            PyTuple_SET_ITEM(%out, 1, %CONVERTTOPYTHON[%INTYPE_1](%in.second));
            return %out;
            </native-to-target>
            <target-to-native>
                <add-conversion type="PySequence">
                %out.first = %CONVERTTOCPP[%OUTTYPE_0](PySequence_Fast_GET_ITEM(%in, 0));
                %out.second = %CONVERTTOCPP[%OUTTYPE_1](PySequence_Fast_GET_ITEM(%in, 1));
                </add-conversion>
            </target-to-native>
        </conversion-rule>
    </container-type>
    <template name="cpplist_to_pylist_convertion">
    PyObject* %out = PyList_New((int) %in.size());
    %INTYPE::const_iterator it = %in.begin();
    for (int idx = 0; it != %in.end(); ++it, ++idx) {
        %INTYPE_0 cppItem(*it);
        PyList_SET_ITEM(%out, idx, %CONVERTTOPYTHON[%INTYPE_0](cppItem));
    }
    return %out;
    </template>
    <template name="pyseq_to_cpplist_convertion">
    Shiboken::AutoDecRef seq(PySequence_Fast(%in, 0));
    for (int i = 0; i != PySequence_Fast_GET_SIZE(seq.object()); i++) {
        PyObject* pyItem = PySequence_Fast_GET_ITEM(seq.object(), i);
        %OUTTYPE_0 cppItem = %CONVERTTOCPP[%OUTTYPE_0](pyItem);
        %out.push_back(cppItem);
    }
    </template>


    <container-type name="std::map" type="map">
        <include file-name="map" location="global"/>
        <conversion-rule>
            <native-to-target>
            PyObject* %out = PyDict_New();
            %INTYPE::const_iterator it = %in.begin();
            for (; it != %in.end(); ++it) {
                %INTYPE_0 key = it->first;
                %INTYPE_1 value = it->second;
            }
            return %out;
            </native-to-target>
            <target-to-native>
                <add-conversion type="PyDict">
                PyObject* key;
                PyObject* value;
                Py_ssize_t pos = 0;
                while (PyDict_Next(%in, %pos, %key, %value)) {
                    %OUTTYPE_0 cppKey = %CONVERTTOCPP[%OUTTYPE_0](key);
                    %OUTTYPE_1 cppValue = %CONVERTTOCPP[%OUTTYPE_1](value);
                    %out.insert(%OUTTYPE::value_type(cppKey, cppValue));
                }
                </add-conversion>
            </target-to-native>
        </conversion-rule>
    </container-type>


<!--   <container-type name="std::set" type="set">
    <include file-name="set" location="global"/>

    <conversion-rule>

      <native-to-target>
      PyObject* %out = PySet_New(0);
      %INTYPE::const_iterator it;
      for (it = %in.begin(); it != %in.end(); ++it) {
        %INTYPE_0 value = *it;
      }
      return %out;
      </native-to-target>

      <target-to-native>

        <add-conversion type="PySet">
        Shiboken::AutoDecRef iter(PyObject_GetIter(%in));
        if (iter.object()) {
          PyObject* item;
          while ((item = PyIter_Next(iter))) {
            %OUTTYPE_0 cppItem = %CONVERTTOCPP[%OUTTYPE_0](item);
            %out.insert(cppItem);
            Py_DECREF(item);
          }
        }
        </add-conversion>

        <add-conversion type="PySequence">
        Shiboken::AutoDecRef seq(PySequence_Fast(%in, 0));
        Py_ssize_t vectorSize = PySequence_Fast_GET_SIZE(seq.object());
        for (Py_ssize_t idx = 0; idx &lt; vectorSize; ++idx) {
          PyObject* pyItem = PySequence_Fast_GET_ITEM(seq.object(), idx);
          %OUTTYPE_0 cppItem = %CONVERTTOCPP[%OUTTYPE_0](pyItem);
          %out.insert(cppItem);
        }
        </add-conversion>

      </target-to-native>

    </conversion-rule>
  </container-type> -->


  <type-template name="std::tr1::shared_ptr">
    <include file-name="memory" location="global"/>
    <arg redirect="%CPPSELF-&gt;get()-&gt;"/>
  </type-template>

  <value-type template="std::tr1::shared_ptr" args="a::b::ShibokenItem"/>

  <namespace-type name="a">
    <namespace-type name="b">
      <object-type name="ShibokenManager" />
      <rejection class="ShibokenManager"
                 function-name="find_item(const std::string&amp;) const"/>
      <object-type name="ShibokenItem" />
    </namespace-type>
  </namespace-type>

</typesystem>

